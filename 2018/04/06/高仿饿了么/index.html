<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta http-equiv="Cache-control" content="public">
<title>施程的博客</title>
<link rel="shortcut icon" href="../../../../img/code.ico" type="image/x-icon">
<title>高仿饿了么</title>
<link rel="stylesheet" href="/../../../../css/post.css">
<link rel="stylesheet" href="/../../../../css/github-markdown.css">
<link rel="stylesheet" href="/../../../../css/github.css">
<script type="text/javascript" src="../../../../js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<div class="wrapper">
  <div class="back-wrapper" id="js-goBack">
    <a href="/">
      <img src="../../../../img/back.svg">
    </a>
  </div>
  <div id="toc-wrapper">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一章：-简介"><span class="toc-number">1.</span> <span class="toc-text">第一章： 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#功能技术分析："><span class="toc-number">1.1.</span> <span class="toc-text">功能技术分析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二章-vuejs介绍"><span class="toc-number">2.</span> <span class="toc-text">第二章 vuejs介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM框架："><span class="toc-number">2.1.</span> <span class="toc-text">MVVM框架：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Vuejs？"><span class="toc-number">2.2.</span> <span class="toc-text">什么是Vuejs？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-js核心思想"><span class="toc-number">2.3.</span> <span class="toc-text">Vue.js核心思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据驱动"><span class="toc-number">2.3.1.</span> <span class="toc-text">数据驱动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据响应原理"><span class="toc-number">2.3.2.</span> <span class="toc-text">数据响应原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件化"><span class="toc-number">2.3.3.</span> <span class="toc-text">组件化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三章-项目文件介绍"><span class="toc-number">3.</span> <span class="toc-text">第三章 项目文件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack"><span class="toc-number">3.1.</span> <span class="toc-text">webpack</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第4章-项目实战-准备工作"><span class="toc-number">4.</span> <span class="toc-text">第4章 项目实战-准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#需求分析"><span class="toc-number">4.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#项目资源准备"><span class="toc-number">4.2.</span> <span class="toc-text">项目资源准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#项目目录设计"><span class="toc-number">4.3.</span> <span class="toc-text">项目目录设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据的mock"><span class="toc-number">4.4.</span> <span class="toc-text">数据的mock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五章-项目实战-页面骨架开发"><span class="toc-number">5.</span> <span class="toc-text">第五章 项目实战-页面骨架开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css技巧"><span class="toc-number">5.1.</span> <span class="toc-text">css技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增加导航栏点击link时的高亮"><span class="toc-number">5.2.</span> <span class="toc-text">增加导航栏点击link时的高亮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导航栏一像素边框的实现"><span class="toc-number">5.3.</span> <span class="toc-text">导航栏一像素边框的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第六章-项目实战-header组件开发"><span class="toc-number">6.</span> <span class="toc-text">第六章 项目实战-header组件开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接受数据"><span class="toc-number">6.1.</span> <span class="toc-text">接受数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染数据"><span class="toc-number">6.2.</span> <span class="toc-text">渲染数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#header的优惠信息浮层"><span class="toc-number">6.3.</span> <span class="toc-text">header的优惠信息浮层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完成公告区"><span class="toc-number">6.4.</span> <span class="toc-text">完成公告区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写背景图"><span class="toc-number">6.5.</span> <span class="toc-text">写背景图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发内部弹层效果"><span class="toc-number">6.6.</span> <span class="toc-text">开发内部弹层效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽离出star组件"><span class="toc-number">6.7.</span> <span class="toc-text">抽离出star组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用star组件"><span class="toc-number">6.8.</span> <span class="toc-text">引用star组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优惠信息的小标题"><span class="toc-number">6.9.</span> <span class="toc-text">优惠信息的小标题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优惠信息正文"><span class="toc-number">6.10.</span> <span class="toc-text">优惠信息正文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作业-抽离出小标题组件"><span class="toc-number">6.11.</span> <span class="toc-text">作业: 抽离出小标题组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渐变展示关闭效果"><span class="toc-number">6.12.</span> <span class="toc-text">渐变展示关闭效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第七章-项目实战-goods商品列表页开发"><span class="toc-number">7.</span> <span class="toc-text">第七章 项目实战-goods商品列表页开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#外层布局"><span class="toc-number">7.1.</span> <span class="toc-text">外层布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最外层"><span class="toc-number">7.1.1.</span> <span class="toc-text">最外层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置好两栏"><span class="toc-number">7.1.2.</span> <span class="toc-text">设置好两栏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置左侧menu区的样式："><span class="toc-number">7.2.</span> <span class="toc-text">设置左侧menu区的样式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置右边商品列表的样式"><span class="toc-number">7.3.</span> <span class="toc-text">设置右边商品列表的样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置滚动"><span class="toc-number">7.4.</span> <span class="toc-text">设置滚动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收尾"><span class="toc-number">7.5.</span> <span class="toc-text">收尾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联动效果"><span class="toc-number">7.6.</span> <span class="toc-text">联动效果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#右侧foods滚动-左侧menu高亮"><span class="toc-number">7.6.1.</span> <span class="toc-text">右侧foods滚动,左侧menu高亮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#点击左侧menu，右侧foods滚动到相应位置"><span class="toc-number">7.6.2.</span> <span class="toc-text">点击左侧menu，右侧foods滚动到相应位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#购物车"><span class="toc-number">7.7.</span> <span class="toc-text">购物车</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cartcontrol组件"><span class="toc-number">7.7.1.</span> <span class="toc-text">cartcontrol组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#联动的动画，抛物的小球"><span class="toc-number">7.7.2.</span> <span class="toc-text">联动的动画，抛物的小球</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#购物车详情"><span class="toc-number">7.8.</span> <span class="toc-text">购物车详情</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第八章-商品详情页"><span class="toc-number">8.</span> <span class="toc-text">第八章 商品详情页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#点击商品，弹出商品的详情页"><span class="toc-number">8.1.</span> <span class="toc-text">点击商品，弹出商品的详情页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ratingselect组件"><span class="toc-number">8.2.</span> <span class="toc-text">ratingselect组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联动，ratingselect与评价列表"><span class="toc-number">8.3.</span> <span class="toc-text">联动，ratingselect与评价列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#formateDate"><span class="toc-number">8.4.</span> <span class="toc-text">formateDate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第九章-评论组件"><span class="toc-number">9.</span> <span class="toc-text">第九章 评论组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十章-商家组件"><span class="toc-number">10.</span> <span class="toc-text">第十章 商家组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#收藏"><span class="toc-number">10.1.</span> <span class="toc-text">收藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#util-js来从url中获取id"><span class="toc-number">10.2.</span> <span class="toc-text">util.js来从url中获取id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用的存储的localStorage库"><span class="toc-number">10.3.</span> <span class="toc-text">通用的存储的localStorage库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目打包"><span class="toc-number">11.</span> <span class="toc-text">项目打包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#课程总结"><span class="toc-number">12.</span> <span class="toc-text">课程总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eslint配置"><span class="toc-number">13.</span> <span class="toc-text">eslint配置</span></a></li></ol>
  </div>
  <article class="markdown-body" id="top">
    <header>
      <h1>高仿饿了么</h1>
      
      
      
      
      <span class="tag">
        <a href="/categories/vue/">
          vue
        </a>
      </span>
      <span class="tag">
        2018-04-06
      </span>
    </header>
    <h2 id="第一章：-简介"><a href="#第一章：-简介" class="headerlink" title="第一章： 简介"></a>第一章： 简介</h2><h3 id="功能技术分析："><a href="#功能技术分析：" class="headerlink" title="功能技术分析："></a>功能技术分析：</h3><p><code>vue-resource</code> : 后端交互</p>
<p><code>vue-router</code> ：前端路由</p>
<p>第三方滚动组件库： <code>better-scroll</code></p>
<p>最大程度组件化</p>
<p>收藏商家 会利用html5 <code>localstorage</code></p>
<p><code>图标字体</code>的使用</p>
<p>移动端<code>1像素</code>边框</p>
<p>css <code>sticky footer</code>布局</p>
<p><code>flex</code>弹性布局</p>
<h2 id="第二章-vuejs介绍"><a href="#第二章-vuejs介绍" class="headerlink" title="第二章 vuejs介绍"></a>第二章 vuejs介绍</h2><ol>
<li><p>旧浏览器逐渐淘汰，移动端需求增加</p>
<p> 旧浏览器一般指的IE6-IE8，不支持ES5特性</p>
<p> 而Vue的一个核心实现就是利用了ES5的<code>Object. defineProperty</code>特性</p>
<p> IE9+ 以及其他均支持ES5</p>
</li>
<li><p>前端交互越来越多，功能越来越复杂</p>
<p> 高大上的技术库和框架，酷炫的运营活动页面，H5小游戏</p>
<p> 更加复杂：</p>
<p> 新闻趣味站；在线购物平台；社交网络；打车出行平台；视频分享平台；音乐互动社区；金融信贷应用等等</p>
</li>
<li><p>架构从传统的后台MVC向<code>REST API+ 前端MV*</code>迁移</p>
</li>
</ol>
<h3 id="MVVM框架："><a href="#MVVM框架：" class="headerlink" title="MVVM框架："></a>MVVM框架：</h3><pre><code>View &lt;--&gt; ViewModel &lt;--&gt; Model
</code></pre><p><code>Model</code>: 数据  <strong>javascript对象</strong></p>
<p><code>ViewModel</code>: 连接视图和数据的<strong>中间件</strong> 通讯，实现一个<code>observer观察者</code>，当数据发生变化，ViewModel可以观察到这种变化，然后通知到对应的视图做自动更新，当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定</p>
<p><code>View</code> : 视图  <strong>DOM</strong></p>
<p>在<code>MVVM</code>的架构下：<strong>视图和数据是不能直接通讯!!!</strong></p>
<p>MVVM的应用场景：</p>
<ul>
<li>针对具有复杂交互逻辑的前端应用</li>
<li>提供基础的架构抽象</li>
<li>通过Ajax数据持久化，保证前端用户体验</li>
</ul>
<p>好处：当前端对数据做一些操作的时候，可以通过ajax请求对后端做持久化，不需要刷新整个页面，只需要改动dom里需要改动的那部分数据和内容，特别是移动端页面的场景，刷新页面的代价太昂贵(会重新加载很多资源，页面的dom/css会被浏览器重新解析一遍)，因为移动端页面通常会做成SPA单页面应用，在这个基础上就诞生了很多mvvm框架</p>
<h3 id="什么是Vuejs？"><a href="#什么是Vuejs？" class="headerlink" title="什么是Vuejs？"></a>什么是Vuejs？</h3><ul>
<li>轻量级MVVM框架</li>
<li>数据驱动+组件化的前端开发</li>
<li>社区完善(怎么看–&gt; github的<code>branch</code> <code>issue</code> <code>star</code>…)</li>
</ul>
<h3 id="Vue-js核心思想"><a href="#Vue-js核心思想" class="headerlink" title="Vue.js核心思想"></a>Vue.js核心思想</h3><h4 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h4><p>DOM是数据的一种自然映射</p>
<p>当没有<code>viewModel</code>时 <code>view &lt;--&gt; model</code> 我们会怎么做？</p>
<p>从后端ajax获取数据的改变，我们会手动触发DOM的改变</p>
<p><strong>有了vue之后就省去了手动操作dom的麻烦</strong></p>
<p><code>model --&gt; Directives --&gt; view</code></p>
<p>vue通过<code>Directives指令</code>去对DOM做一层封装，当数据发生变化，会通知指令去修改对应的dom，数据驱动dom变化，<strong>DOM是数据的一种自然映射</strong></p>
<p>vuejs还会对操作进行监听，当我们修改视图的时候，vuejs监听到这些变化，从而改变数据</p>
<p>这样就形成了数据的双向绑定</p>
<h4 id="数据响应原理"><a href="#数据响应原理" class="headerlink" title="数据响应原理"></a>数据响应原理</h4><p>数据(<code>model</code>)改变驱动视图(<code>view</code>)自动更新</p>
<p>实例化时会有<code>getter/setter</code>方法,还会生成指令对象，每一个指令对象都会关联一个<code>watcher</code>, 有更新时调用指令的<code>update</code>方法</p>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>目的：<code>扩展html元素</code>，<code>封装可重用的代码</code></p>
<p>每一个组件都对应着一个<code>viewModel</code></p>
<p>组件设计原则:</p>
<ul>
<li><p>页面上每个独立的可视/可交互区域视为一个组件</p>
</li>
<li><p>每一个组件对应一个工程目录，组件所需要的各种资源在这个目录就近维护</p>
</li>
<li><p>页面不过是组件的容器，组件可以嵌套自由组合形成完整的页面</p>
</li>
</ul>
<h2 id="第三章-项目文件介绍"><a href="#第三章-项目文件介绍" class="headerlink" title="第三章 项目文件介绍"></a>第三章 项目文件介绍</h2><p><code>static</code>：目录用来存放一些第三方静态资源 </p>
<p><code>.gitkeep</code>：是为了即使你创建一个空目录也会被提交到git代码仓库里面(平常如果你创建一个空目录,git提交时会被忽略)</p>
<p><code>.babellrc</code>：babel编译的一些配置 </p>
<ul>
<li><code>presets</code>表示预设 <code>stage-2</code>表示<code>ECMA草案</code>(0-3 2-3)  </li>
<li><code>plugins</code>表示插件，<code>transform-runtime</code>…  </li>
<li><code>comments: false</code> 表示生成后的代码不包括注释</li>
</ul>
<p><code>.editconfig</code>：编辑器的配置</p>
<p><code>.eslintgnore</code>：忽略语法检查的文件</p>
<p><code>.eslintrc.js</code>：eslint的配置文件</p>
<p>重点看一下<code>extends</code>和<code>rules</code>这两个选项</p>
<p><code>standard</code>可以去官网看一下规则</p>
<p>可以通过<code>rules</code>对具体的规则进行修改</p>
<p><code>.gitgnore</code>：git仓库忽略掉这些目录或文件</p>
<p>packjson目录：</p>
<p>dependencies:</p>
<p><code>&quot;vue&quot; : &quot;^1.0.21&quot;</code> 向上的箭头表示最低安装xxx, 会安装最新的</p>
<p>webstorm有一个自动格式化：<code>command + option + L/ Control + alt + L</code></p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h2 id="第4章-项目实战-准备工作"><a href="#第4章-项目实战-准备工作" class="headerlink" title="第4章 项目实战-准备工作"></a>第4章 项目实战-准备工作</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>6张设计稿</p>
<p>首页: 有商品/评价/商家三个标签页</p>
<p>商品页面：</p>
<p><code>header</code>是商家简介，点击<code>header</code>的详情可以弹出悬浮层，</p>
<ul>
<li>选菜区 与<code>siderbar</code>有一个滚动时联动的效果；</li>
<li>当点击<code>+号</code>时，会有动画加入到购物车里面，此时的商品总数和价格会自动更新，当金额超过最小配送费的时候，旁边的去结算的按钮会自动亮起；</li>
<li>购物车没什么东西的时候点击是没反应的，当有物品的时候，点击购物车就会向上弹出购物列表</li>
</ul>
<p>当我们点击某一个具体的商品的时候，就会显示具体的商品页浮层</p>
<p>商品页浮层：</p>
<ul>
<li>手机宽度自适应的，宽高相等的大图;  </li>
<li>评论区可以通过标签来筛选; </li>
<li>有返回按钮，点击浮层会关闭</li>
</ul>
<p>商家页面时，当商家实景的图超过手机屏幕时，会可以左右滚动，上下超过手机屏幕时可以上下滚动</p>
<h3 id="项目资源准备"><a href="#项目资源准备" class="headerlink" title="项目资源准备"></a>项目资源准备</h3><p>一般要准备<code>2X</code>和<code>3X</code>图</p>
<p><code>dpr</code>的存在：设备像素比</p>
<p><a href="http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/" target="_blank" rel="external">设备像素比devicePixelRatio简单介绍</a></p>
<p>为什么不用<code>css spirite</code>合并，而要去切成单张图？</p>
<p>css spirite的目的是为了减少网络请求</p>
<p>而<code>webpack</code>会帮我们把图片<code>base-64</code>，然后打包到js文件中，这样的话我们甚至连一个图片资源请求都不会有</p>
<p>在移动端，我们通常会把一些<code>色彩单一的图片做成svg</code></p>
<p>那么我们在实际中我们会怎么使用这些svg图片？</p>
<p>我们会把这些svg图片通过工具转换成图标字符文件，就可以在css中引用这些图标字体文件</p>
<p>如何去制作一个<code>图标字体</code>？</p>
<p><a href="https://icomoon.io/app/#/select" target="_blank" rel="external">icomoon</a> </p>
<p>点击左上角的<code>import icons</code>, 导入自己的svg图片，选中，点击右下角的<code>generate fonts</code> 按钮，在<code>get code</code>中 我们就可以看到怎么使用这些图标字体文件了,在<code>downloa</code>d之前，点击<code>preference</code>，修改font-name为你项目相关的名字,接下来直接下载即可</p>
<p>怎么使用？ 压缩包里面有<code>demo</code>，引入项目只要<code>fonts目录</code>和<code>style.css文件</code>即可</p>
<h3 id="项目目录设计"><a href="#项目目录设计" class="headerlink" title="项目目录设计"></a>项目目录设计</h3><p>在一个项目代码编写之前，我们要做的是对项目的目录结构进行设计</p>
<p>所有代码都会放在<code>src</code>下，会有一个<code>main.js</code>的入口文件，<code>App.vue</code>文件是整个页面的vue实例文件，也就是把整个页面看成是整个Vue的大组件</p>
<p>子目录<code>components</code>是存放子组件，一个子组件(新建一个文件夹)除了包含<code>.vue</code>文件外还可能包含图片，相关资源等等，组件一个很重要的原则就是就近维护，把相关资源都放在一起，对外是隔离的，这样非常有利于代码的维护</p>
<p>在src目录下我们还需创建一个<code>common</code>目录，在这个目录下，去包含一些公共的模块或资源，新建<code>js/stylus/fonts</code>目录</p>
<h3 id="数据的mock"><a href="#数据的mock" class="headerlink" title="数据的mock"></a>数据的mock</h3><p>前后端分离，前端有一个很重要的任务就是数据的<code>mock</code></p>
<p>在<code>dev-server.js</code>里面配置</p>
<h2 id="第五章-项目实战-页面骨架开发"><a href="#第五章-项目实战-页面骨架开发" class="headerlink" title="第五章 项目实战-页面骨架开发"></a>第五章 项目实战-页面骨架开发</h2><p><code>app.vue</code>的大组件</p>
<p><code>header</code>组件</p>
<p><code>goods/ratings/sellers</code>三个组件，组件切换用<code>vue-router</code>来实现</p>
<p><code>import header from &#39;components/header/header.vue&#39;</code>会报错找不到，这时我们可以修改为<code>&#39;./components/header/header.vue&#39;</code></p>
<p><code>./</code>表示当前目录</p>
<p><code>export default</code> 表示把整个的当作<code>module.export</code>导出的</p>
<p>注册组件为<code>header</code>时会报<code>Do not use built-in or reserved HTML elements as component id: header</code>的警告，它不让你用原生的html标签作为组件名, 这时可以取一个别名</p>
<pre><code>//在app.vue里面
components: {
  &apos;v-header&apos;: header
}
</code></pre><p>所以我们统一用<code>&quot;V-XXX&quot;</code>来表示这是vue组件</p>
<p>导航栏：</p>
<p>移动端，经典<code>flex</code>布局</p>
<p>移动端设计稿一般按<code>iphone6</code>设计的，<code>dpi为2</code>，故设计稿的px已经乘以了2，例如 设备像素是<code>375px</code>，但物理像素是<code>750px</code></p>
<p>标注稿是80px 因为设计师已经x2了 我们只要40px </p>
<p>在F12查看页面元素时，会发现自动添加了一些页面兼容性的写法，例如display:-moz-flex 等等，原因是因为vue-loader会依赖一个<code>postcss</code>的插件，这个插件会自动帮我们搞定一些css兼容性的写法</p>
<p>导航栏：点击 商品/评论/商家 怎么实现内容区的跳转</p>
<p>vue-router</p>
<p>为什么<code>import vueRouter from &#39;vue-router&#39;;</code>这里的vue-router,怎么知道这个名字的？</p>
<p>到node_modules找到vue-router,打开他的package.json可以看到<code>&quot;name&quot;: &quot;vue-router&quot;</code></p>
<p>v-link来控制路由的切换，<code>&lt;router-view&gt;&lt;/router-view&gt;</code>用来显示路由切换后要显示的内容变化区，此处为<code>div class=&quot;content&quot;</code></p>
<p>Vue 2.0不可以用v-link的形式了，而是 <code>&lt;router-link to=&quot;/goods&quot;&gt;商品&lt;/router-link&gt;</code></p>
<p>相对路径的坑 <code>import seller from &#39;./components/seller/seller&#39;;</code></p>
<p>例如我们并不希望每次都要写当前的main.js引入对应组件时的相对路径，这样写当子组件很多的时候，会写很多的代码，直接所有的都通过<code>components</code>这样的开头去找即可： </p>
<p>可以在<code>webpack.base.conf.js</code>中修改，设置<code>alias</code>(别名)：<code>&#39;component&#39;: path.resolve(__dirname,&#39;../src/components&#39;)</code></p>
<p>对于Vue-router 2.0打开应用跳转到默认路由，似乎只有这个方法？</p>
<pre><code>{
    path: &apos;/&apos;,
    redirect: &apos;/goods&apos;
}
</code></pre><p><code>router.go(&#39;/goods&#39;)</code>可以用在1.0，2.0中有这个方法为<code>go(n)</code>不知道怎么用…</p>
<h3 id="css技巧"><a href="#css技巧" class="headerlink" title="css技巧"></a>css技巧</h3><p>stylus这段代码中的<code>&amp; &gt; a</code>的意思，字符<code>&#39;&amp;&#39;</code>指向父选择器，<code>&#39;&gt;&#39;</code>表示选择父元素class为tab-item的元素的所有 <a> 元素</a></p>
<pre><code>.tab-item
    flex: 1
    text-align: center
    &amp; &gt; a
      display: block
</code></pre><p>利用static里面的reset.css可以在原有的基础，自定义一些css重置样式，如a标签的<code>text-decoration: none;</code></p>
<p>css的写法是有规律的，例如，<code>display</code>,<code>position</code>这样的样式一般会写在前面(影响布局的元素会先写在前面)，然后宽高，<a href="https://www.cnblogs.com/zhutao/p/6551216.html" target="_blank" rel="external">会触发reflow(回流)和repaint(重绘)</a>的一些不可被弃写的css样式也会被写到前面一点(在布局之后)，最后才会设置一些像字体啊颜色啊可被弃权的，<code>重绘但不影响重排</code>，这些可被弃权的属性<code>放到最后面</code></p>
<p>extends: 浏览器工作原理：</p>
<ul>
<li><a href="http://www.cnblogs.com/Peng2014/p/4687218.html" target="_blank" rel="external">浏览器渲染页面原理</a></li>
<li><a href="http://blog.jobbole.com/12749/" target="_blank" rel="external">现代浏览器的工作原理</a></li>
</ul>
<h3 id="增加导航栏点击link时的高亮"><a href="#增加导航栏点击link时的高亮" class="headerlink" title="增加导航栏点击link时的高亮"></a>增加导航栏点击link时的高亮</h3><p>使用vue-router 2.0想要高亮当前激活的元素，有这个</p>
<p>当 <code>&lt;router-link&gt;</code> 对应的路由匹配成功，将自动设置 <code>class</code> 属性值 <code>.router-link-active</code></p>
<p>注意这样的类名太长，你想要修改的话，可以通过修改<code>new VueRouter({/*...*/})</code>的配置项<code>linkActiveClass</code>来实现，如下所示：</p>
<pre><code>const router = new VueRouter({
  linkActiveClass: &apos;active&apos;,
  routes
});
</code></pre><h3 id="导航栏一像素边框的实现"><a href="#导航栏一像素边框的实现" class="headerlink" title="导航栏一像素边框的实现"></a>导航栏一像素边框的实现</h3><p>直接加 <code>border-bottom: 1px solid rgba(7,17,27,0.1)</code>(有透明度就要用rgba)的问题是：</p>
<p>pc端浏览的时候的确看起来是1px，但是手机端的问题是，有dpr的概念，如果iphone6则为2倍的设备像素与物理像素，也就是在iphone6上看上去就是一个两像素的线了</p>
<p>技巧：如何在pc开发移动端页面时用手机预览？</p>
<ol>
<li><code>http://localhost:8090/#/goods</code>把localhost换成本机的ip地址，例如<code>192.168.1.2</code></li>
<li>把转换后的地址贴到<a href="https://cli.im/" target="_blank" rel="external">草料二维码</a>，去把这个url生成一个二维码</li>
<li>保证你的手机和电脑在同一个局域网，然后用你的手机来扫那个二维码即可</li>
</ol>
<p>那么如何真正的生成一个一像素呢？</p>
<p>在这个元素后添加一个伪类<code>after</code>，然后把after设置为一条线，然后在不同dpr的手机上进行一个<code>mediaquery</code>来实现对这个线的缩放</p>
<ol>
<li><p>希望一像素比较通用，定义一个<code>mixin</code>(也就是css预处理器提供的一个特殊的方法)，在common/stylus下创建一个mixin.stylu </p>
<p> 记录一个小bug</p>
<pre><code>border-1px($color)
      position: relative
      &amp;:after
        display: block
        position: absolute
        width: 100%
        top: 0
        bottom: 0
        border-top: 1px solid $color
        content: &apos; &apos;
</code></pre><p> 当<code>position: absolute</code>却指定的是<code>top:0 ;bottom:0</code>的时候，会出现伪类after把应用伪类的那个元素全部覆盖了，此处的表现就是不能在被点击，因为点击的都是after…</p>
</li>
<li><p>添加<code>@import &quot;./common/stylus/mixin.styl&quot;</code>引入这个mixin即可在css中使用了</p>
</li>
</ol>
<ol>
<li><p>接下来给这个伪类线做一个缩放，目的就是为了自适应不同的dpr，给当前的要应用1px的元素再添加一个border-1px的class，然后我们要去全局的定义这个class，我们需要在stylus里面声明一个base.styl</p>
<p> @media (-webkit-min-device-pixel-ratio: 1.5), (-min-device-pixel-ratio: 1.5)<br>   .border-1px</p>
<pre><code>&amp;::after 
  -webkit-transform: scaleY(0.7)  //
  transform: 0.7
</code></pre><p> @media (-webkit-min-device-pixel-ratio: 2), (-min-device-pixel-ratio: 2)<br>   .border-1px</p>
<pre><code>&amp;::after
  -webkit-transform: scaleY(0.5)
  transform: 0.5
</code></pre></li>
<li><p>要全局的引用这个styl，就需要在main.js里面import，这里可以使用一个优化技巧,增加一个index.styl来作为全局引用的入口</p>
<p> @import “base.styl”<br> @import “mixin.styl”<br> @import “icon.styl”</p>
</li>
</ol>
<p>总结：我们是怎么实现一个下边框的1px的？(上边框，变成<code>before</code>伪类)</p>
<p>主要是利用了<code>伪类加缩放</code>的这两个功能，在需要一px边框的元素上定义一个伪类，然后伪类相对于这个元素是绝对定位，通过伪类去画一个1px的边框，然后我们把它定位这个元素的下面，然后我们在去应用一个class去对这个伪类进行缩放(纵轴Y轴进行缩放)</p>
<p>页面基本骨架已经搭好了，接下来开发header组件和下方的content等..</p>
<h2 id="第六章-项目实战-header组件开发"><a href="#第六章-项目实战-header组件开发" class="headerlink" title="第六章 项目实战-header组件开发"></a>第六章 项目实战-header组件开发</h2><h3 id="接受数据"><a href="#接受数据" class="headerlink" title="接受数据"></a>接受数据</h3><p>设计稿上可以看到，header组件有很多关于商家的信息，这些信息是通过异步请求后端的接口来获得的，我们的header组件就是接受这些数据，并渲染</p>
<p>那我们就可以通过在header组件的父组件<code>app.vue</code>中发送一个ajax请求来获取商家的数据，然后通过header的一个<code>props</code>属性传递给这个组件</p>
<p>在vuejs中规定<code>data</code>是一个函数，因为组件是可以被复用的，如果被定义为对象的话，如果你修改某一个组件的话，会影响另外的组件</p>
<p>然后<code>return</code>一个<code>seller</code>的对象</p>
<p>使用<code>vue-resource</code>来处理的前后端请求交互</p>
<p>vue-resource相当于给<code>vue实例</code>添加了一个<code>$http</code>的属性</p>
<p>vue实例都有一个生命周期，其中有一个<code>created</code>的钩子，在这里来发ajax请求</p>
<p>在vue-resource早期版本中，箭头函数的参数response不是一个json对象，要使用.json()方法来转换成json对象</p>
<p>注意返回的json数据要进行errno(在express里面添加的)判断来判断数据的状态(符合生产实际)</p>
<p>小技巧：如果我们直接判断<code>if(response.errno === 0) {/*balabala*/}</code>这样的话，我们并不能很好的知道这个0是什么意思….，如果我们写死为0，假设某天我们不要这个状态，我们需要改动为其他的话，会改动多个地方，用类似于常量的这种方法，如果我们以后想要改状态码，那么我们只要在一个地方改</p>
<blockquote>
<p>注意代码风格尽量有语义</p>
</blockquote>
<p>通过在外部设置<code>const ERR_OK = 0;</code>然后<code>if(response.errno === ERR_OK) {/*balabala*/}</code></p>
<p>小技巧：当我们遇到异步，却出现页面没接受到数据或说没反应的时候，我们可以通过devtools的networking的xhr来查看异步请求是否被返回了，再回到代码中去debug</p>
<h3 id="渲染数据"><a href="#渲染数据" class="headerlink" title="渲染数据"></a>渲染数据</h3><p>当我们能从后端成功的获取到数据的时候，我们可以通过<code>v-bind</code>这个指令来把<code>seller</code>(从后端获得的数据)传递到header组件</p>
<pre><code>&lt;v-header :seller=&quot;seller&quot;&gt;&lt;/v-header&gt;
</code></pre><p>在header组件中定义<code>props</code>来接受这个seller  </p>
<pre><code>props: {
    seller: {
        type: Object
    }    
}
</code></pre><p>根据设计稿来分析，图片区和商家介绍区(两列)以及底部的公告区,商家介绍区再区分为三个div，title,描述，还有一些支持情况</p>
<p>图片img元素一般指定宽高，按照设计稿的图片标注，设置好<code>width</code>和<code>height</code></p>
<p>一个小技巧：在显示<code>support</code>s时为什么要加<code>v-if=&quot;seller.supports&quot;</code>？</p>
<p>如果不加，那么我们在一开始，由于app.vue在created的时候发出的ajax是异步的，所以一开始我们可能会传送了一个空的seller对象，所以如果不进行判断就直接写<code>seller.supports[0].desc</code>会弹出vue的报错</p>
<p>header的布局完成，接下来要应用css来进行</p>
<p>首先header的布局</p>
<p>span为行内元素，宽高是由其内容撑开的，不能通过设置宽高来控制(哪怕span里面有内容)，只能通过<code>display:inline-block</code></p>
<p>可以看到我们用到bran背景图片时分为2X和3X，但dpr为2的时候使用2x，为3用3x，这个时候我们就需要写一个<code>mediaquery</code>，但是每一个都要我们去写一下mediaquery的话，代码会很多，解决方法：<strong>写一个mixin来统一适配</strong></p>
<p>在<code>mixin.styl</code>里写好<code>bg-image()</code>函数后，注意的是，需要在<code>header.vue</code>中引用这个styl的路径，而且之前在<code>script</code>标签中我们是可以通过<code>webpack</code>设置别名的方法来引用这里是不可以的，只能通过相对路径</p>
<p><code>font-size:36px</code>的文字仍然要按照dpr为2来折半</p>
<p><code>title</code>栏 让图片与文字对齐，通过设置图片<code>vertical-align: top</code>来实现</p>
<p>title结束，接下来写<code>description</code></p>
<p>可以看到无论description还是其他均有<code>font-weight:200</code>，这时候就可以不用重复的写，在<code>base.styl</code>中添加一些默认的样式</p>
<p>可以看到avator里面img的src指向了一个线上图片的地址，而title里面的brand使用的<code>background-image</code>却是<code>base-64</code>的，这是由于wepack编译的原因</p>
<p><code>support</code>有点麻烦的地方就是，图标需要根据后端返回的值来决定显示哪一个，解决的办法就是前端有不同的<code>class</code>来对应不同的图标</p>
<p>先写好css，通过不同的class名对应不同的<code>bg-image</code>，在<code>template</code>里面通过<code>v-bind:class</code>来实现class的动态绑定</p>
<p>但是<code>data.json</code>里面是通过<code>type=0，1，2，3...</code>这样返回值的，我们拿到不同的type的值要怎么匹配class呢？</p>
<p>在<code>created(){}</code>方法中我们可以在vue实例创建的时候来建立一个<code>classmap</code>数组对应好它们的关系</p>
<h3 id="header的优惠信息浮层"><a href="#header的优惠信息浮层" class="headerlink" title="header的优惠信息浮层"></a>header的优惠信息浮层</h3><p>相对加绝对定位，但文字和字体图标不对齐，此时使用<code>vertical-align: top</code>却发现字体图标并不像之前的图片一样可以实现跟文字顶部对齐，而是变成顶到最上边去了</p>
<p>此时可以查看一下i元素，发现它的<code>line-height: 1;</code>，要想垂直居中的话，line-height必须等于height</p>
<h3 id="完成公告区"><a href="#完成公告区" class="headerlink" title="完成公告区"></a>完成公告区</h3><p>三个部分，icon，文字，箭头(可以展开蒙层)，文字超过内容会展示点点点的缩略</p>
<p>要实现不折行，实现点点点的效果，有三个组合的属性：</p>
<pre><code>white-space: nowrap
overflow: hidden
text-overflow: ellipsis
</code></pre><p>为了<code>icon</code>的span与文字的span不要有间隙，设置了<code>font-size: 0</code>，之后文字span的…省略效果却没了…</p>
<p>又想不要空白间隙，又想保留省略号的效果，可以通过在html里面把换行删除</p>
<p>设置icon与文字对齐，同样设置了<code>vertical-align: top</code>之后icon顶到最上面去了</p>
<p>icon是12px，高度是28px，则再加上<code>margin-top: 7px</code> (28-12)/2</p>
<p>但是发现一个问题：如果不去掉<code>font-size: 0</code>，那么不会有省略号的效果，如果去掉了呢，居中对齐还是实现不了</p>
<p>解决：通过对<code>.bulletin-title</code>和<code>.bulletin-text</code>均设置<code>vertical-align: top</code>可以解决</p>
<h3 id="写背景图"><a href="#写背景图" class="headerlink" title="写背景图"></a>写背景图</h3><p>背景图就是<code>avator</code>的图片，再加上一个模糊的效果</p>
<p>置于外层的容器，再加上<code>filter: blur</code>就可以实现</p>
<p>具体的方法: 利用一个充满整个header区的div，巧妙的利用<code>z-index:-1</code>，把这个div变成背景</p>
<pre><code>&lt;div class=&quot;background&quot;&gt;
  &lt;img :src=&quot;seller.avatar&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
&lt;/div&gt;

/*****css:******/
.background
  position: absolute
  top: 0
  left: 0
  width: 100%
  height: 100%
  z-index: -1
  filter: blur(10px)
</code></pre><p>但是需要注意的是，header的背景必须设置为透明，这样的话才可以透过背景看到</p>
<pre><code>.header 
  background: rgba(7, 17, 27, 0.5)
</code></pre><h3 id="开发内部弹层效果"><a href="#开发内部弹层效果" class="headerlink" title="开发内部弹层效果"></a>开发内部弹层效果</h3><p>由于上次的背景div设置了<code>filter: blur(10px)</code>的效果，让模糊的效果跑到了nav区去了</p>
<p>解决：在.header设置<code>overflow: hidden</code>即可</p>
<p>全屏效果，模糊效果，底部有一个关闭的效果，但是本身高度可能比手机的高度更高，底部的关闭按钮需要<code>sticky</code></p>
<p>如果用<code>position: fixed</code>布局的话，那么关闭按钮一直相对与窗口而不是内容，这就是一个经典的<code>CSS Sticky footers布局</code></p>
<p>首先是一个满屏的<code>fixed</code>，但是我们需要控制弹层是否显示</p>
<p>在vue里面用<code>v-show</code>来控制是否显示，v-show给元素添加了一个<code>style=&quot;display:none;&quot;</code></p>
<p>vue在实例化时，会遍历data对象里面的变量，去给它们添加getter/setter,这样变量变化时，dom能跟着变量变化而变化</p>
<p>CSS Sticky footers布局方法之一：</p>
<p>套路一：首先固定结构：</p>
<pre><code>&lt;div class=&quot;detail-wrapper clearfix&quot;&gt;
  &lt;div class=&quot;detail-main&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;detail-close&quot;&gt;&lt;/div&gt;
</code></pre><p>套路二：<code>detail-wrapper</code>用来包裹内容，需要随着它的内容自动增高，通过设置<code>min-height: 100%</code><br>，也就是最小高度要跟视口一样高</p>
<p>套路三：<code>detail-main</code>需要设置<code>padding-bottom: 64px</code>，这里的64px是因为, 字体图片的<code>font-size: 64px</code>加上下边距是64px，除以2，得出来的，也就是detail-main的<code>padding-bottom</code>是为了给<code>detail-close</code>留出空间</p>
<p>套路四：<code>detail-close</code>因为是跟<code>detail-wrapper</code>平级的，需要设置<code>负margin</code>，这里是<code>margin: -64px auto 0</code></p>
<p><code>clearfix</code>有固定的样式</p>
<p>detail-wrapper的宽度是被内容撑开的，视频中是按标注先设计好标题(<code>class=&quot;name&quot;</code>)样式，再在detail-wrapper中设置<code>width:100%</code>，也可以先设宽度百分百，再设样式</p>
<h3 id="抽离出star组件"><a href="#抽离出star组件" class="headerlink" title="抽离出star组件"></a>抽离出star组件</h3><p>star组件：可以看到设计稿中有多处的评价星，而且都是水平排列，判断逻辑也一致(满星和半星，0.5增)，这个时候我们可以考虑抽象成一个组件</p>
<p>首先把设计师的星星图，切成单个的, 分为<code>off/on/half</code>三种状态的星星</p>
<p>其次组件首先要考虑拓展性: 我们直接如下，一个div带5个span，写死的话这样拓展性就太差了，如果我们有6颗星呢？</p>
<pre><code>&lt;div&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
  &lt;/div&gt;
</code></pre><p>正确写法：</p>
<pre><code>&lt;div class=&quot;star&quot; :class=&quot;starType&quot;&gt;
    &lt;span v-for=&quot;itemClass in itemClasses&quot; :class=&quot;itemClass&quot;     class=&quot;star-item&quot;&gt;&lt;/span&gt;
  &lt;/div&gt;
</code></pre><p>动态绑定<code>starType</code>，star有不同尺寸，wrapper层肯定会有不同的样式，需要给每一个span都创建自己的class，所以需要创建一个<code>itemClasses</code>的数组，当然也可以有公共的<code>class：star-item</code>(或者说是基础的class)</p>
<p>外部将尺寸大小传给<code>star</code>(size: 24/36/48; score:评价得分)，而<code>starType</code>就是通过计算这两个参数，映射成一个类型(使用vue的<code>computed</code>计算属性)</p>
<p>计算星星的宽度，和psd图(没有…)中设计的总宽度，通过减除等就可以得出间隙的宽度</p>
<p>写star组件的css：</p>
<pre><code>.star
    .star-item
    &amp;.star-48
        .star-item
    &amp;.star-36
        .star-item
    &amp;.star-24
        .star-item
            &amp;:last-child
            &amp;.on
            &amp;.half
            &amp;.off
</code></pre><p>其中的&amp;是指跟父元素同级，就理解成css中的</p>
<pre><code>.star .star-item {/*code here*/}

.star-48 .star-item {/*code here*/}
</code></pre><p><code>star-item</code>写出基础属性，<code>star-xx</code>通过计算属性来匹配，分为<code>on/off/half</code>分别调用不同的背景星，需要注意的是，最后一个星星是只需要<code>margin-right=0</code>的</p>
<p>最后一步怎么把<code>itemClass</code>动态的设置成<code>on/off/half</code></p>
<p>通过计算属性<code>itemClasse(){ /*...*/}</code></p>
<p>向下取<code>0.5</code>的倍数</p>
<p><code>let score = Math.floor(this.score * 2) / 2;</code></p>
<p>这样就把小数的数全部区分成了0.5的倍数，4.0或4.5或5.0，例如 </p>
<pre><code>4.2 =&gt; 4  

4.6 =&gt; 4.5

4.5 =&gt; 4.5 
</code></pre><p>判断是否有小数，也就是取0.5，有多少半星(因为正整数除以2都只可能余0.5)</p>
<p><code>let hasDecimal = score % 1 !== 0;</code></p>
<p>判断有多少满星</p>
<p><code>let interger = Math.floor(score);</code></p>
<h3 id="引用star组件"><a href="#引用star组件" class="headerlink" title="引用star组件"></a>引用star组件</h3><p>import之后就只要</p>
<p><code>&lt;star :size=&quot;48&quot; :score=&quot;seller.score&quot;&gt;&lt;/star&gt;</code></p>
<p>再用包裹div即可</p>
<h3 id="优惠信息的小标题"><a href="#优惠信息的小标题" class="headerlink" title="优惠信息的小标题"></a>优惠信息的小标题</h3><p>需求分析：中间标题，左右两边线</p>
<p>按设计稿把线固定宽度可以吗？ 如果屏幕很大或者很小的话，写死的线很容易就出现边距过大或满屏，然后文字的div浮于线上时，要注意与背景一致</p>
<p>注意: 为什么这次的div内部没有采用span，而是继续用的div嵌套div？</p>
<p>因为在某些安卓浏览器下，用span会有点问题。。。</p>
<h3 id="优惠信息正文"><a href="#优惠信息正文" class="headerlink" title="优惠信息正文"></a>优惠信息正文</h3><p>样式与前述的差不多一致，留作作业</p>
<h3 id="作业-抽离出小标题组件"><a href="#作业-抽离出小标题组件" class="headerlink" title="作业: 抽离出小标题组件"></a>作业: 抽离出小标题组件</h3><h3 id="渐变展示关闭效果"><a href="#渐变展示关闭效果" class="headerlink" title="渐变展示关闭效果"></a>渐变展示关闭效果</h3><p><code>v-enter</code>: 元素由<code>display:none</code>变为空，先显示出来，然后在这个元素显示之后，插入一帧<code>v-enter</code></p>
<p>为什么不是<code>fade-enter</code> 与<code>fade-leave</code>呢(与<code>fade-leave-active</code>)?</p>
<p>如果写leave的话就会直接从1变成透明度0，然后下一帧就被移除了</p>
<p>小技巧：</p>
<p>消除空隙： </p>
<ol>
<li>父元素设置<code>font-size:0</code>，每个子元素设置font-size</li>
<li>span与span之间消除换行符也可</li>
</ol>
<h2 id="第七章-项目实战-goods商品列表页开发"><a href="#第七章-项目实战-goods商品列表页开发" class="headerlink" title="第七章 项目实战-goods商品列表页开发"></a>第七章 项目实战-goods商品列表页开发</h2><p>是这个项目里面最复杂的部分</p>
<p>两栏布局，左侧固定宽度，右侧跟手机的宽度自适应(flex布局)</p>
<h3 id="外层布局"><a href="#外层布局" class="headerlink" title="外层布局"></a>外层布局</h3><h4 id="最外层"><a href="#最外层" class="headerlink" title="最外层"></a>最外层</h4><p>最外层包裹<code>goods</code>需要设置绝对定位来固定视口大小</p>
<pre><code>display: flex
position: absolute
// 相对于header组件需要top: 174px
top: 174px  
// 相对于底部的购物车需要bottom: 46px
bottom: 46px
width: 100%
overflow: hidden
</code></pre><h4 id="设置好两栏"><a href="#设置好两栏" class="headerlink" title="设置好两栏"></a>设置好两栏</h4><p>左边固定80px,右边自适应</p>
<pre><code>.menu-wrapper
    flex: 0 0 80px
    width: 80px
    background: #f3f5f7
.foods-wrapper
    flex: 1
</code></pre><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">flex语法</a></p>
<p>flex属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写,</p>
<p><code>flex: 1</code> 表示：</p>
<pre><code>/* One value, unitless number: flex-grow */
flex: 2;
</code></pre><p><code>flex: 0 0 80px</code>表示<code>flex-basis: 80px</code></p>
<blockquote>
<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间</p>
</blockquote>
<h3 id="设置左侧menu区的样式："><a href="#设置左侧menu区的样式：" class="headerlink" title="设置左侧menu区的样式："></a>设置左侧menu区的样式：</h3><p>获取<code>mock</code>数据，然后ul标签来显示，注意留一个作业，将<code>classmap</code>抽象成一个组件</p>
<pre><code>&lt;ul&gt;
  &lt;li v-for=&quot;item in goods&quot; class=&quot;menu-item&quot;&gt;
    &lt;span class=&quot;text&quot;&gt;
      &lt;span v-show=&quot;item.type&gt;0&quot; class=&quot;icon&quot; :class=&quot;classmap[item.type]&quot;&gt;&lt;/span&gt;{{item.name}}
    &lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>ul中li的文字，需要垂直居中，而且当文字多于一行时，也要垂直居中，这个样式怎么写？</p>
<p>运用<code>display: table</code></p>
<p>由于menu-item, 设置的width为56px，而li是80px要实现居中，需要设置<code>padding: 0 12px</code>  </p>
<p>实现垂直居中，利用<code>table-cell</code>加<code>vertical-align</code>即可</p>
<blockquote>
<p><code>vertical-align</code>有两种用法，一种是用于行内元素的，一种是用于<code>table-cell</code>元素</p>
<p>To vertically align an inline element’s box inside its containing line box</p>
<p>To vertically align the content of a cell in a table</p>
</blockquote>
<pre><code>display: table-cell;
vertical-align: middle
</code></pre><p>先写好样式和布局，再实现功能</p>
<h3 id="设置右边商品列表的样式"><a href="#设置右边商品列表的样式" class="headerlink" title="设置右边商品列表的样式"></a>设置右边商品列表的样式</h3><p>标题按设计稿即可，接下来是<code>food-item</code>，同样flex布局，<code>icon</code>图标固定宽度，内容自适应</p>
<p>注意最后一个<code>food-item</code>不能有<code>border-1px</code>，那么怎么取消掉border-1px呢？</p>
<pre><code>border-none()
  &amp;:after
    display: none
</code></pre><p>这样即可，因为border-1px是利用了伪类实现，直接把伪类<code>display:none</code>就可以了，然后基本的其他样式可以按照设计稿来</p>
<h3 id="设置滚动"><a href="#设置滚动" class="headerlink" title="设置滚动"></a>设置滚动</h3><p>借用第三方库<a href="https://github.com/ustbhuangyi/better-scroll" target="_blank" rel="external">betterscroll</a></p>
<p>引入: <code>new BScroll()</code>时需要两个参数，第一个参数是一个dom对象，第二个参数是一个json对象，那么dom对象在vue里面是怎么获得的呢？</p>
<pre><code>&lt;div class=&quot;menu-wrapper&quot; ref=&quot;menuWrapper&quot;&gt;

this.$refs.menuWrapper //这时就可以取到这个dom对象了
</code></pre><p>注意：在视频中，vue1.0，写成<code>v-el=&quot;menu-wrapper&quot;</code>，在引用的时候需要用驼峰”<code>menuWrapper</code>“，但在vue2.0时，<code>ref</code>是一个属性，直接接受一个<code>string</code>，不需要在引用时再转为驼峰写法</p>
<p>一开始直接写<code>this._initScroll();</code>,但是并不能滚动？</p>
<p>虽然我们知道，在vue里面我们更改数据，dom会随着数据做映射，但实际上vue在更新dom的时候是一个异步的，也就是说vue里面有一个叫<code>$nextTick</code>的，实际上在nextTick的回调里面才会更新</p>
<p>所以在我们一开始接受mock数据的时候，<code>this.goods = response.data;</code>，虽然改变了数据，但是此时的dom并没有变化，dom没有变化的时候，传入BScroll就会在计算高度的时候有问题</p>
<pre><code>this.$nextTick(() =&gt; {
    this._initScroll();
});
</code></pre><p>把它放入<code>nextTick</code>里，这样就可以更新了， </p>
<p>因为这个时候它已经拿到内存ul的高度了，这个高度和wrapper层的高度进行对比，当ul的高度大于wrapper的高度的时候，它就可以做滚动</p>
<h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>清除span空隙，<code>.desc</code>有多行时，<code>line-height=&quot;10px&quot;</code>不够，上下靠的太近，改成12px即可</p>
<h3 id="联动效果"><a href="#联动效果" class="headerlink" title="联动效果"></a>联动效果</h3><h4 id="右侧foods滚动-左侧menu高亮"><a href="#右侧foods滚动-左侧menu高亮" class="headerlink" title="右侧foods滚动,左侧menu高亮"></a>右侧foods滚动,左侧menu高亮</h4><p>当右侧<code>foods</code>滚动时，左侧的<code>menu</code>区域会有相应的高亮效果，而且点击<code>menu</code>，右侧<code>foods</code>会滚动到相应的位置</p>
<p>思路：要知道右侧滚动，实时变化的y值，也就是纵坐标y轴落到哪个区间，对应的左侧menu就要显示哪个区间</p>
<p>怎么计算y值落到哪个区间呢？我们要知道每个区间的高度，首先我们要计算整体的区间的高度，比如第一个区间最大高度是多少，我们要记录下来，依次第二个…，记录这样的一个数组，然后监听滚动的时候，拿到y坐标，然后去对比，y落到哪个区间，然后得到左侧menu高亮区域的索引值，再利用vue的一个<code>class</code>绑定，把高亮的效果写出来</p>
<p>在<code>this._initScroll();</code>之后增加一个计算高度的函数<code>this._calculateHeight();</code></p>
<p>怎么得到实时的y值？ 通过<code>BestScroll</code>库，new BScroll时传入第二个json对象参数</p>
<pre><code>this.foodsScroll = new BScroll(this.$refs.foodsWrapper, {
    probeType: 3
});
</code></pre><p>然后监听滚动，<code>Math.round()</code>返回数字值四舍五入到最接近的整数，<code>Math.floor()</code>返回小于等于给定数字的最大整数，这样就可以实时获得<code>scrollY</code>值</p>
<pre><code>this.foodsScroll.on(&apos;scroll&apos;, (pos) =&gt; {
    this.scrollY = Math.abs(Math.round(pos.y));
});
</code></pre><p>然后在li元素上挂载一个<code>hook</code>(‘food-list-hook’)，来获得所有的li元素，每一个<code>foodlist</code>的高度包括标题和内容，获取高度用<code>clientHeight</code>(包括<code>height+padding</code>,但不包括margin和水平滚动条的高度)</p>
<p>注意：得到一个高度数组，是递增的，也就是，从0开始，然后第一个区块的高度，第一个加第二个区块的高度…，因为这样才符合滚动的实际</p>
<p>接下来就要把<code>scrollY</code>与左侧的索引进行一个映射</p>
<p>用vue里面特别好用的一个属性：<code>computed</code>属性</p>
<p>定义一个<code>currentIndex</code>，遍历初始化的<code>listHeight</code>，看scrollY是否落在两个数组元素之间，是则返回当前的index</p>
<p>注意一开始加载的时候高度是0，这样的话，判断条件得改成<code>this.scrollY &gt;= height1 &amp;&amp; this.scrollY &lt; height2</code>也即要开始闭区间，结尾开区间</p>
<p>这样当<code>scrollY</code>变化的时候，<code>currentIndex</code>会重新做计算，然后在<code>menu-wrapper</code>绑定一个class, 当currentIndex与当前<code>v-for</code>的<code>index</code>相等的时候，就会被设置<code>current</code>的class</p>
<p><code>&lt;li v-for=&quot;(item, index) in goods&quot; class=&quot;menu-item&quot; :class=&quot;{&#39;current&#39;: currentIndex === index }&quot;&gt;</code></p>
<p>然后设置current的样式即可</p>
<h4 id="点击左侧menu，右侧foods滚动到相应位置"><a href="#点击左侧menu，右侧foods滚动到相应位置" class="headerlink" title="点击左侧menu，右侧foods滚动到相应位置"></a>点击左侧menu，右侧foods滚动到相应位置</h4><p>在menu的li元素监听点击事件，但是测试点击的时候发现点击事件没有触发？</p>
<p>因为<code>BScroll</code>监听了<code>touchstart</code>、<code>touchend</code>等事件，然后它会<code>preventDefault</code>,所以要在初始化BScroll时，传一个属性<code>click</code></p>
<p>但是有一个问题，当把<code>chrome</code>模式改成电脑(退出手机模式)的时候，会出现点击一次，触发两次点击，也就是在PC页面，一开始BScroll是不会阻止点击事件的(初始化的时候，传<code>click:true</code>是默认派发了一个点击事件，这样就会派发两个点击事件)</p>
<p>怎么解决？ 在点击的时候除了传一个<code>index</code>还可以传一个<code>event</code>,<code>@click=&quot;selectMenu(index, $event)&quot;</code></p>
<blockquote>
<p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法</p>
</blockquote>
<p>在BScroll中派发的事件和原生的dom事件有区别</p>
<pre><code>if (!event._constructed) {
    return;
}
</code></pre><p>在方法中加入这个判断，当为派发的事件时，<code>event._constructed</code>为<code>true</code>, 原生的则为false，之后直接被<code>return</code>掉</p>
<p>总结一下： 当我们写vue开发应用的时候，遇到某些和原生的一些库做交互的时候，需要注意几个点</p>
<p>首先可以通过<code>ref</code>，<code>$refs</code>访问到，就相当于拿到一个原生dom</p>
<p>其次需要注意的是，<code>$nextTick</code>，当我们想要计算一些跟dom相关的东西时，我们一定要保证dom已经渲染了，因为虽然在vue里面，dom是数据的自然映射，我们改变了数据就改变了dom，但是dom真正的变化是发生在<code>$nextTick</code>的回调函数后，所以我们在操作原生dom的时候，我们一定要调用<code>this.$nextTick()</code>，然后这个回调中做任何事情，这样就是非常安全的</p>
<p>小技巧：</p>
<ol>
<li>能用<code>class</code>的时候，一定要用class来写这个样式</li>
</ol>
<p>有多个id级联的话，效率是比较低的</p>
<ol>
<li><p>class为了让js来选择的时候，我们给它加一个<code>hook</code>,表明它是一个被js选择的样式，而这个样式并没有实际的效果，例如<code>class=&quot;food-list food-list-hook&quot;</code></p>
</li>
<li><p>一般碰到<code>undefined is not a function</code> , 要去看一下前面调用这个函数的对象是不是<code>undefined</code></p>
</li>
</ol>
<h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><p>左右两块，右边结算是固定宽度，左边是自适应宽度</p>
<p>写<code>shopcart</code>的样式时，突出的边缘为<code>12+10px</code>,10px未在设计稿中标注出来</p>
<p>使用<code>position: relative; top: -10px</code>来实现<code>logowrapper</code>超过<code>shopcart</code>的效果，top的高度怎么计算？ <code>(116-96)/2=10px</code></p>
<p><code>logowrapper</code>的圆形外廓标注12px,注意左右两边的36px，实际包括了padding的12px，所以样式中为<code>margin:0 12px</code></p>
<p>为什么宽高要设为56px，是因为此处用<code>box-sizing:border-box</code>，这样宽度是包括padding和margin的，也即<code>(88px+12px+12px)/2=56px</code></p>
<p>最后设<code>border-radius: 50%</code>来实现一个圆，再<code>display: inline-block</code>的居中通常是<code>vertical-align: top</code>顶部对齐，然后如果没有设background的话，看不出效果，因为会透明的，直接透的底色，加上<code>background: #141d27</code>与之前一样的背景色即可</p>
<p>填logo:</p>
<p>宽高撑满父元素即可，同样设置圆角，其余样式按照设计稿来即可</p>
<p>记录一个小疑问：为什么设置了用<code>f12</code>去查看的时候，却并不是一个圆，而仍是一个正方形？ 回到盒模型，<code>border</code>是在<code>padding</code>与<code>margin</code>之间的…  待解</p>
<p>设置.price，margin-top是12px, 为什么居中用<code>margin-top: 12px;line-height: 24px</code>而不直接用<code>line-height: 48px</code>(直接等于shopcart高度即可)呢？</p>
<p>因为右边还有一个竖线，而这个竖线我们是用的<code>border-right: 1px solid rgba(255, 255, 255, 0.1)</code>来写的，如果是写的<code>line-height: 48px</code>的话，那这个线的高度就相当于撑满整个区块了，这样就不符合我们的要求了</p>
<p>设置<code>.desc</code>，注意字体在设计稿上标注错了，font-size为10px</p>
<p>然后怎么接受价格参数？</p>
<p>通过seller，之前的header可以使用seller是因为在<code>app.vue</code>中通过<code>&lt;v-header :seller=&quot;seller&quot;&gt;&lt;/v-header&gt;</code>传入了seller，</p>
<p>那么shopcart组件要使用seller，也要传入，在<code>app.vue</code>的<code>&lt;router-view :seller=&quot;seller&quot;&gt;&lt;/router-view&gt;</code>中传入给goods组件，</p>
<p>之后在goods.vue中<code>&lt;shopcart :delivery-price=&quot;seller.deliveryPrice&quot; :min-price=&quot;seller.minPrice&quot;&gt;&lt;/shopcart&gt;</code>传参，在<code>shopcart.vue</code>中接受</p>
<pre><code>props: {
  deliveryPrice: {
    type: Number,
    default: 0
  },
  minPrice: {
    type: Number,
    default: 0
  }
}
</code></pre><p>这样即可，注意，一个习惯吧，vue在<code>props</code>接受参数时，一定要指定<code>type</code>和如果有默认值的话，还要指定默认值</p>
<p>写结算的样式，按设计稿</p>
<p>但是购物车的状态是有很多的，购物车主要是一个选择商品的映射，goods这个组件来告诉shopcart选择了多少商品, 它要维护的是我选择了多少商品，而选择了多少商品应该也是通过props属性来传给shopcart</p>
<p>定义一个：</p>
<pre><code>//vue里面如果props的type是array或者object，default值要为一个函数
selectFoods: {
    type: Array,
    default() {
      return [];
    }
},
</code></pre><p><code>selectFoods</code>保存了我们选择商品的数组，然后<code>price</code>就可以根据<code>selectFoods</code>来做计算了，在goods组件中每个<code>item.foods</code>下面都有一个food，我们再给food添加一个属性<code>count</code>(在data.json里面)表示food选择了多少个，要得到<code>totalPrice</code>(总价)跟<code>selectFoods</code>之间的关系，要用到计算属性<code>computed</code></p>
<p><code>mock</code>：selectFoods里面 </p>
<pre><code>return [
    {
      price: 10,
      count: 2
    }
];
</code></pre><p>可以看到页面上返回的就是￥20了</p>
<p>购物车还有logo的地方，和结算的样式都会随着<code>selectFoods</code>发生变化</p>
<p>logo右上角的<code>count</code>，<code>computed</code>里面新增一个<code>totalCount</code>,计算总数量, 然后新增div，显示，样式绝对布局，参考设计稿即可</p>
<p>当我们有商品添加(count数不为0)，logo需要有高亮的效果，可以先设置高亮的样式，再通过动态绑定class实现，<code>:class=&quot;{&#39;highlight&#39;:totalCount&gt;0}&quot;</code>，同样给price也加上高亮</p>
<p>当取消<code>selectFoods</code>里面的mock时，发现logo右上角的count还在，需要给<code>num</code>加上一个<code>v-show</code>，因为v-show支持表达式，<code>v-show=&quot;totalCount&gt;0&quot;</code></p>
<p>还缺右侧结算区块的变化，总共有3种状态，第一种没有买任何商品的时候，显示多少元起送，第二种买了一点商品但没有达到起送费的时候，就会显示还差多少元起送，第三种如果已经够了的话，就会显示去结算</p>
<p>所有的状态变化都依赖于<code>selectFoods</code>，总价0的话，显示起送价，不为0则有一个计算差，总价大于起送价的时候就显示去结算，总价小于起送价但大于0的时候，就显示还差多少元</p>
<p>在computed里面新增一个<code>payDesc()</code>来计算状态，返回不同的字符串，“多少元起送”，“还差多少元起送”，“去结算”，但是<code>pay</code>在“多少元起送”、“还差多少元起送”和“去结算”之间只有两种样式，还需要再设一个<code>payClass</code>的计算属性来确定使用哪个<code>class</code></p>
<p>回想一下，如果我们不是用<code>MVVM框架</code>，我们用<code>jq</code>的方式，像这样比较复杂的状态变化，则肯定需要在代码中各种判断，去操作dom，让class改变啊之类的，而我们这里并没有写这些代码，我们改变的只是数据(<code>selectFoods</code>)，状态就自然的变了，然后把计算属性的表达式写好以后，dom就自然跟着变化(用了<code>动态class</code>，<code>v-show</code>等)，这也就是vue的数据驱动的一个好处</p>
<h4 id="cartcontrol组件"><a href="#cartcontrol组件" class="headerlink" title="cartcontrol组件"></a><code>cartcontrol</code>组件</h4><p>接下来，写按钮，在foods里面有，在购物车浮层里面也有，我们可以把它抽离成一个<code>cartcontrol</code>组件</p>
<p><code>cartcontrol</code>关联的的是单个的<code>food</code>,每一个商品购买的个数</p>
<p><code>props</code>接受一个<code>food</code>，类型是<code>Object</code>，因为是<code>v-for</code>遍历<code>foods</code>时，传入<code>food</code>给<code>cartcontrol</code>，注意先用一个wrapper的div包装用来给cartcontrol定位</p>
<p>传值写法： <code>：food=&quot;food&quot;</code></p>
<p>测试组件是否被传值，</p>
<pre><code>created() {
  console.log(this.food);
}
</code></pre><p>给cartcontrol写样式，减号和加号为字体, 按照设计稿的要求即可，注意要用<code>padding</code>撑开</p>
<p>当一开始点击加号的时候，数字会出现，加1，并且减号也会出现</p>
<p>在加号按钮上添加addCart事件，发现点击并没有效果啊。。。因为cartcontrol-wrapper是在BScroll里面，要在移动端点击，需要在初始化BScroll的时候传一个参数(在foodsScroll中也加上click:true即可)，但是仍然存在pc和移动端的问题，即PC端会点击两次(老方法解决)</p>
<p>但是又发现点击了加号后，却数字没有显示出来，也就是<code>v-show=&quot;food.count&gt;0&quot;</code>，food.count没有加，这其实是vue的问题，我们通过addCart给food新增count属性，但是vue是检测不到对象新增属性的变化的，要实现检测</p>
<pre><code>import Vue from &apos;vue&apos;;

Vue.set(this.food, &apos;count&apos;, 1);
</code></pre><blockquote>
<p>通过Vue.set方法设置对象的属性，如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制</p>
</blockquote>
<p>同样减号按钮也这样添加样式和方法，但点击按钮的动画，还可以优化，看起来会有点生硬</p>
<p>希望做一个，点击+号，然后减号和数字，是平移滚动出来，这样就有两个动画要做，平移和滚动，基于vue的transition过渡动画来实现</p>
<pre><code>opacity: 1
transform: translate3d(0, 0, 0) /*translate3d用于硬件加速*/
</code></pre><p>为了设置内层的滚动，还需给.inner设置样式</p>
<p>动画暂不详述。。。</p>
<p>做完cartcontrol选择组件，还有shopcart购物组件，之后要考虑的是如何将这两个组件关联起来</p>
<p>在goods组件中，给shopcart传入selectFoods，注意写法<code>:select-foods=&quot;selectFoods&quot;</code>要用中划线，然后在计算属性中去遍历哪些food是被选择了，怎么知道被选择？因为我们在cartcontrol中，用了<code>Vue.set</code>这会给food加上count属性(也会影响到goods组件里面的food)，只需在goods的计算属性中判断<code>if (food.count) {/***/}</code>即可，原理是因为，计算属性监听的是goods，goods内部有food，food的count变化(因为点击+-)，就相当于goods发现变化，它就被重新进行计算，这样完成了联动</p>
<h4 id="联动的动画，抛物的小球"><a href="#联动的动画，抛物的小球" class="headerlink" title="联动的动画，抛物的小球"></a>联动的动画，抛物的小球</h4><p>接下来，增加联动的动画，抛物的小球，原理有点类似上面的，y轴控制一个方向，x轴控制一个方向，</p>
<p>在shopcart组件中加一个div</p>
<pre><code>&lt;div class=&quot;ball-container&quot;&gt;
  &lt;transition name=&quot;drop&quot;&gt;
    &lt;div v-for=&quot;ball in balls&quot; v-show=&quot;ball.show&quot; class=&quot;ball&quot;&gt;
      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/transition&gt;
&lt;/div&gt;
</code></pre><p><code>ball</code>定位在购物车<code>logo</code>处</p>
<p>需要知道起始点元素的相对于屏幕的位置，要获得这个位置，首先要获得这个元素，获得这个元素，需要在点击+的时候，让这个组件派发一个事件，把它的dom对象给传出来</p>
<p><code>this.$dispatch(&#39;cart.add&#39;, event.target);</code>//dom对象作为这个事件的参数传入</p>
<p>父组件goods接受子组件传来的事件：</p>
<pre><code>events: {
    &apos;car.add&apos;(target) {

    }
}
</code></pre><p>当父组件拿到这个事件后呢，它需要调用子组件的一个方法 :<code>this._drop(target);</code>，shopcart里面定义这个drop方法</p>
<p>这样就实现了把组件A(也就是shpcart)里面的dom元素传递给了父组件，然后父组件再调用子组件的方法</p>
<p>父组件要访问子组件：在goods里面的shopcart，加<code>ref=&quot;shopcart&quot;</code>，再在_drop方法中<code>this.$refs.shopcart</code>就可以访问到子组件，然后<code>this.$refs.shopcart.drop(target);</code>就可以访问到<code>drop</code>方法</p>
<p>记录一下vue1.0迁移到2.0：</p>
<pre><code>&lt;div class=&quot;ball-container&quot;&gt;
  &lt;transition name=&quot;drop&quot;&gt;
    &lt;div v-for=&quot;ball in balls&quot; v-show=&quot;ball.show&quot; class=&quot;ball&quot;&gt;
      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/transition&gt;
&lt;/div&gt;
</code></pre><p>当写成这样时，是不行的，会报错，<code>transition</code>只能用于单个的元素，请用<code>transition-group</code>代替</p>
<p><a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" target="_blank" rel="external">$dispatch已被废弃</a>，在这里改成<code>this.$emit(&#39;add&#39;, event.target);</code>，$dispatch是通过子组件向父组件冒泡，把事件一层层的冒出去，<code>emit</code>实际上是在当前实例下派发一个事件，什么叫当前实例，就是我们在这里emit一个事件，我们只能在当前组件下去on这个事件，才能监听到，而不能在它的父组件监听到，例如：</p>
<pre><code>//在cartcontrol中emit一个事件
 this.$emit(&apos;add&apos;, event.target);

//在goods组件(父组件)的cartcontrol 通过add来监听到
&lt;cartcontrol :food=&quot;food&quot;  @add=&quot;addFood&quot;&gt;
</code></pre><p>这样父组件要调用子组件的方法的时候，就可以在<code>addFood</code>方法中了</p>
<p><code>drop</code>方法，从所有的<code>balls</code>里面找到一个隐藏的<code>ball</code>(<code>show:false</code>)，然后显示，保存elem，把这个ball添加到<code>dropBall</code>里面</p>
<p><code>beforeEnter</code>, <code>dropping</code>, <code>afterDrop</code>三个均接受一个<code>el</code>，为经历transition的dom对象， <code>beforeEnter</code>要把所有设为<code>true</code>的小球都找到，这些小球就是要做动画的，</p>
<pre><code>if (ball.show) {
    let rect = ball.el.getBoundingClientRect();
    let x = rect.left - 32;
    let y = -(window.innerHeight - rect.top - 22);
    el.style.display = &apos;&apos;;
    el.style.webkitTransform = `translate3d(0, ${y}px, 0)`;
    el.style.transform = `translate3d(0, ${y}px, 0)`;
    let inner = el.getElementsByClassName(&apos;inner-hook&apos;)[0];
    inner.style.webkitTransform = `translate3d(${x}px,0,0)`;
    inner.style.transform = `translate3d(${x}px,0,0)`;
}
</code></pre><p>如果是要做动画的话，通过<code>getBoundingClientRect()</code>: returns the size of an element and its position relative to the viewport，再通过<code>rect</code>的<code>left</code>和<code>top</code>属性来计算y，<code>window.innerHeight</code>是视口的高度，我们要计算的是从起始点到购物车logo的那点的x和y差值</p>
<p><code>enter：el.offestHeight;</code>手动取得<code>offestHeight</code>来触发浏览器重绘，然后在<code>this.$nextTick()中</code>把样式会置回来</p>
<p><code>afterEnter:</code>做完一个动画取一个ball，把<code>show</code>置<code>false</code>，并且<code>display:none</code></p>
<p>一开始拼错了<code>let rf = el.offestHeight;</code>，会出现一些bug，例如一开始点击没效果，而且小球出现后掉入购物车logo的时候又会卡在那，不消失，还有点下面的按钮，上面飞入等…，原因是vue在设置动画的时候，需要重绘，只要当重绘后再设置<code>transform</code>才有用</p>
<p>在手机上点击的时候，发现点击+，同时触发两个动画的时候会有点卡，那么怎么去优化？ 在父组件的<code>_drop</code>方法里不要立马调用子组件的<code>drop</code>方法</p>
<pre><code>_drop(target) {
  // 体验优化，异步执行下落动画
  this.$nextTick(() =&gt; {
    this.$refs.shopcart.drop(target);
  });
}
</code></pre><p>注意当加上<code>this.$nextTick</code>的时候，因为要考虑这是一种不同寻常的代码写法，要用注释表明自己的意思</p>
<h3 id="购物车详情"><a href="#购物车详情" class="headerlink" title="购物车详情"></a>购物车详情</h3><p>首先布局，<code>head/ul</code>，导入<code>cartcontrol</code>组件，要给shopcart加一个变量<code>fold</code>来表示是否折叠，因为购物车详情的<code>v-show=&quot;listShow&quot;</code>要考虑<code>food.count</code>是否大于0，而且是否已经被点开</p>
<p>记录一个小bug，文字不显示(标题，价格等)，设置字体为黑色之后可以，但是不知道为什么？ 可能是<code>z-index:-1</code>引起吗？</p>
<p>给区块加上<code>BScroll</code></p>
<p>记录一个小bug，当点击购物车详情里面的cartcontrol的+-号的时候，会出现toggleList也被点击的情况，vue2.0里面有click修饰符，在cartcontrol中的<code>@click=&quot;addCart($event)&quot;</code>加上修饰符，变成<code>@click.stop.prevent=&quot;addCart($event)&quot;</code>就可以防止事件冒泡了，<code>.stop</code>用于阻止事件冒泡，<code>.prevent</code>用于阻止默认行为，还有如<code>.self</code>等一些其他有用的<a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="external">事件修饰符</a></p>
<p>加上背景，半透明，背景模糊</p>
<p>因为相对于整个屏幕，需要与shopcart组件同级，铺满屏幕，再<code>z-index</code>比shopcart小即可实现，加上动画</p>
<p>记录一个vue2.0的要求，模版变化，组件只允许有一个根节点，当<code>&lt;div class=&quot;shopcart&quot;&gt;</code>直接同级写<code>&lt;div class=&quot;list-mask&quot;&gt;</code>的时候，需要有一个整个div包裹这两部分，不然就会报错</p>
<p>设置点击背景也可以实现toggleList的关闭效果，只需要设置<code>fold=false</code>即可，因为背景只会在弹出之后出现啊</p>
<p>点击结算的时候，仍然会触发toggleList，需要防止事件冒泡</p>
<h2 id="第八章-商品详情页"><a href="#第八章-商品详情页" class="headerlink" title="第八章 商品详情页"></a>第八章 商品详情页</h2><h3 id="点击商品，弹出商品的详情页"><a href="#点击商品，弹出商品的详情页" class="headerlink" title="点击商品，弹出商品的详情页"></a>点击商品，弹出商品的详情页</h3><p>记录一个小bug，为什么在验证food组件是否被引用，在chrome对food的样式进行<code>display:none</code>切换时，只有同时设置了<code>left/top/bottom</code>或者<code>top/bottom</code>才可以呢？ 如果只有<code>left/top</code>或者<code>left/bottom</code>都没反应…</p>
<pre><code>.food {
    position: fixed;
    left: 0;
    top: 0;
    bottom: 48px;
    width: 100%;
    z-index: 30;
    background: #fff;
}
</code></pre><p>解决： 很简单，你没有设高度啊！！！，但为什么不设高度，只设置bottom的时候，却可以正常呢？，就理解成你设置好了三个边距，也就设置好了整个元素的宽高了啊</p>
<p><code>goods</code>组件点选food，然后显示food组件，同样根据父组件来调用子组件的方法来实现显示，然后设置从左到右的动画</p>
<p>之后图片</p>
<p>当设置<code>padding-top</code>或者<code>bottom: 100%</code>的时候，是相对于width的，而我们设置</p>
<pre><code>width: 100%
height: 0
padding-top: 100%
</code></pre><p>这样的hack手段就可以实现一个宽高相等的容器，手机宽度一般小于高度，直接按手机宽度来做正方形</p>
<p>之后返回按钮，注意用一个div包裹字体图标，div负责定位，然后对i进行padding</p>
<p>之后content，按照设计稿的要求即可，能抽象成一个组件的一个基本原则就是基本的css样式和布局都是一致的(price)</p>
<p>内容区很有可能超过组件的高度，使用BScroll，但是我们不想要滚动条，BScroll的结构是一个父层，绑定层是有固定高度的，是视口的高度，内层是内容层，就是第一个子节点，当这个层的高度超过了父层，BScroll就可以做一个滚动，引用BScroll的时候务必要用<code>this.$nextTick</code>，因为只有nextTick的时候才能保证DOM是渲染的，高度才能被计算对</p>
<pre><code>// 经典代码  ref加在class=&quot;food&quot;处
this.$nextTick(() =&gt; {
  if (!this.scroll) {
    this.scroll = new BScroll(this.$els.food, {
      click: true
    });
  } else {
    this.scroll.refresh();
  }
});
</code></pre><p>之后，加入购物车的按钮以及点击加入购物车之后的<code>cartcontrol</code>，用两个同级div来表示，注意写样式的时候，因为cartcontrol有一个<code>6px的padding</code>，所以只需写12px即可，</p>
<p>还有一个小bug，不知道为什么视频中的老师的做法是直接让<code>cartcontrol-wrapper</code>与<code>buy</code>与<code>content</code>同级，但是却发现自己的如果这样的话直接，按钮就是相对于<code>food-content</code>(…后来视频改过来了…)</p>
<p>food的动画问题： vue1.0升级成2.0，但是从此变成<code>on</code>和<code>emit</code>事件只能在同一个实例上触发(似乎措词有点不当，算了)，要解决food组件点击+号仍有小球飞入的效果，就需要事件连续的冒出，总之就是通过不断的<code>$emit</code>子组件的<code>dom元素</code>解决的…</p>
<p><code>split</code>组件，因为很多地方都用到了隔离，直接抽象成一个组件</p>
<h3 id="ratingselect组件"><a href="#ratingselect组件" class="headerlink" title="ratingselect组件"></a><code>ratingselect</code>组件</h3><p>商品详情页和评价页的评价选择区都有相同的结构、样式，抽象成<code>ratingselect</code>组件，思考一下这个组件，这个组件要关联哪些props</p>
<p>首先要有个变量控制是否显示只看内容，还有一个变量控制选择的类型(例如选择的是全部，推荐还是吐槽)，还要去维护一个所有评价的数组，还要去维护一个描述，这个描述可以动态的传入配置(可以是全部、推荐、吐槽也可以是全部、满意、不满意)</p>
<p>评价分为正向，负向以及全部，可以用常量表示(可读性更强)，这样<code>selectType</code>的数据类型也就是<code>Number</code></p>
<p><code>food</code>引用<code>ratingselect</code>组件，底部的<code>rating</code>要与<code>ratingselect</code>进行关联互动，先在food组件中的<code>data</code>同样定义这些变量和常量，然后在<code>show</code>方法(由<code>goods</code>组件来调用)再进行初始化，<code>onlyContent</code>置为<code>true</code>，<code>selectType</code>置为<code>ALL</code></p>
<p>设置样式，为什么对<code>rating</code>不设置<code>全padding: 18px</code>呢？</p>
<p>可以在设计稿中看到有一条线是贯穿我们的横轴的，如果对<code>rating</code>(父元素)使用了左右padding的话，这样内容区相当于被限制在里面，线根本不能水平铺满，只使用<code>padding-top</code>，而且内部元素用<code>margin</code>隔开这样即可实现，还有设计稿标题下方标了12px，实际是不用，因为组件即是向上36px的(包含了)</p>
<p><code>selectType</code>主要由三个方块组成，三个方块宽高都是一致的，全部和推荐的样式其实是一样的，只不过一个是选中的状态，一个是未选中，吐槽也有两种状态，未选中是灰色，选中是一个深灰色，ui设计上只要把透明度去掉即可实现选中高亮，<code>selectType</code>有两种样式，一种是公共样式(宽高大小和选择)，一种是特殊样式，可用<code>positive</code>和<code>negative</code>表示，改变透明度的高亮属性</p>
<p>给<code>selectType</code>和<code>switch</code>都添加事件，注意有<code>BScroll</code>，默认点击事件还是要被<code>return</code>掉，接着直接将<code>ratingtypeSelect</code>和值，<code>contentToggle</code>(可以不含值，因为就两个状态)给emit父组件，如果直接在本组件里面进行<code>this.selectType = type;</code>，vue会进行警告：大致意思就是这是<code>prop</code>传过来的属性，如果直接进行重写，可能会覆盖父组件传过来的值，请利用<code>data</code>或者<code>computed</code>属性来对prop的值进行操作</p>
<blockquote>
<p><code>Avoid mutating a prop directly</code> since the value will be overwritten whenever the parent component re-renders. Instead, use a <code>data</code> or <code>computed</code> property based on the prop’s value. <code>Prop being mutated: &quot;selectType&quot;</code></p>
</blockquote>
<p>将本来写死的评论数，改成根据<code>prop</code>值，全部的评论可以用<code>ratings.lengt</code>h得到，但是<code>positive</code>和<code>negative</code>的数量呢？利用vue的<code>computed</code>属性，来过滤ratings数组里面所有<code>rateType</code>为POSITIVE的元素，返回这个只含POSITIVE的数组</p>
<h3 id="联动，ratingselect与评价列表"><a href="#联动，ratingselect与评价列表" class="headerlink" title="联动，ratingselect与评价列表"></a>联动，ratingselect与评价列表</h3><p>先写评价列表的样式，需要考虑评论有的时候和暂无评论的时候，故还需要设置一个div用与<code>no-rating</code>的展示，具体样式参考设计稿，在li元素加一个v-show接受一个<code>needShow</code>函数，<code>needShow</code>传入<code>rating</code>的<code>rateType</code>和<code>text</code>，首先我们判断是否要显示内容，只要内容不存在或者<code>onlyContent</code>设为false的时候就返回false，再去判断<code>selectType</code>是否是选择的全部，如果是全部的话，返true，否则再去判断当前的<code>rateTyp</code>e是否等于<code>selectType</code>，返回其值</p>
<p>BScroll并未随着点击是否显示内容而高度变化，当点击的时候，例如在父组件的<code>toggle</code>方法里面需要去使用<code>this.scroll.refresh()</code>来使BScroll刷新，但是直接刷新肯定是有问题的，因为我们在给<code>this.selectType</code>赋值的时候，dom还没刷新，要用到异步刷新，<code>this.$nextTick</code></p>
<p>当显示为空的时候，我们要显示一个暂无评价的文案</p>
<h3 id="formateDate"><a href="#formateDate" class="headerlink" title="formateDate"></a>formateDate</h3><p>给时间戳加上一个filter，进行date的转化，在<code>common</code>的js目录下下定义一个<code>date.js</code>的文件，注意导出格式为：</p>
<pre><code>export function formatDate(date, fmt) {

}
</code></pre><p>在food中引入的格式为：<code>import {formatDate} from &#39;@/common/js/date&#39;;</code></p>
<p>也就是说<code>export default</code> 是不用带大括号的，而<code>export function</code>是需要带，而且还可以带多个function，例如<code>{formateDate,a...}</code></p>
<p>实现<code>formateDate</code>方法，用正则去动态替换字符串里的<code>yyyy</code>,<code>mm</code>之类的，年份要特别处理一下，其他的用对象存储，遍历属性，注意<code>RegExp.$1</code>是获得第一个匹配，然后要取字符串最后两个，有技巧，<code>(&#39;00&#39; + str).substr(str.length)</code></p>
<blockquote>
<p>The literal expression RegExp.$1 will get you the value of the first capture group of the last regex ran</p>
</blockquote>
<p>至此 food组件就开发完成了，购物，评论，BScroll</p>
<h2 id="第九章-评论组件"><a href="#第九章-评论组件" class="headerlink" title="第九章 评论组件"></a>第九章 评论组件</h2><p>注意，如果在<code>score-wrapper</code>中设置<code>line-height</code>为<code>18px</code>的话，会导致<code>margin-bottom</code>有些太宽了，解决方法是在子元素上设置line-height，原因还需考虑一下</p>
<p>为什么送达时间，多少分数，不用<code>inline-block</code>，<code>vertical-align:top</code>，因为这两个元素都是文字，需要的情况就是图片和文字对齐的那种</p>
<p>如果是在<code>iphone5</code>下是会有问题的，不是水平的，错乱了，因为iphone5的水平宽度不够，会导致折行，所以为了预防这种情况呢？需要加一个<code>mediaquery</code>，对<code>overview-left</code>的flex要有一个mediaquery，还有<code>overview-right</code>的padding-left需要变小，以及star组件的margin也要变小，<code>@media only screen and (max-width: 320px)</code></p>
<p>具体评论列表参考设计稿，注意图片写死宽高，<code>recommend</code>的<code>item</code>需要向下的<code>margin</code>用来防止多行的情况</p>
<p>联动效果：参考之前</p>
<h2 id="第十章-商家组件"><a href="#第十章-商家组件" class="headerlink" title="第十章 商家组件"></a>第十章 商家组件</h2><p>再次回顾下<code>BScroll</code>的结构，外层有一个容器<code>wrapper</code>，它有一个固定的视口高度，内层就是一个div，这个div是可以被内容自动撑高的，所以当内层容器的高度会超过视口高度的话，它就可以滚动</p>
<p>常常会忘记：传入一个<code>props</code>，是需要用<code>：</code>号引入</p>
<p>同样有这个问题，给父元素设<code>line-height</code>的话会把高度撑高，需要改成给每一个子元素设<code>line-height</code></p>
<p>引入BScroll与其他组件不同的是，这次需要在ready方法中引用，因为不需要从后端取得数据不用在<code>created</code>里面</p>
<p>但引入后发现不能滚动…，应该是高度计算不对，可以在network的XHR中点击查看，seller是异步获取的，内容是靠seller里面的数据撑开的，所以一开始内容肯定是小于wrapper的，在ready里面<code>console.log</code>一下seller会发现，什么都没有…，注意这里和视频中的有差距，如果直接watch到数据变化，调用<code>_initScroll</code>方法，会出现还是没有效果，参考他人后，发现加上<code>this.nextTick</code>后就可以了，可能是因为vue1.0和2.0的差别，seller数据变了还需要下一个tick更新dom</p>
<p>后续，当点击评论选项卡切换的时候，会出现再切回seller的时候，又不能滚动了，因为dom变化，而此时的<code>watch</code>方法是不会被执行的，应该放入到ready方法里面调用<code>_initScroll</code>方法</p>
<p>注意vue2.0已经没有了ready方法，改为<code>mounted</code></p>
<p>还有为什么要加else的<code>this.scroll.refresh()</code>;？不加的话，会出现这样的情况，一开始不能滚动，但是切换选项卡之后就可以滚动了，这是因为ready(mounted)的优先级是高于<code>watch</code>的，设置了<code>ready(mounted)</code>之后，先执行<code>ready(mounted)</code>里面的<code>_initScroll</code>方法，但是if判断为<code>false</code>(但是此时的<code>this.scroll</code>已经被初始化了)，而之后watch调用之后发现this.scroll已经被初始化了，就什么也不做(第一次打开不能被滚动)</p>
<p>另：为什么在<code>support-item</code>里面不可以加<code>border:none</code>，而三等分的block里面却可以用??</p>
<pre><code>//support-item
&amp;:last-child
      border-none();

//block
&amp;:last-child
        border: none
</code></pre><p>另：在vue1.0中<code>v-el</code>如果标识符出现连字符，需要用<code>驼峰</code>的写法，但在vue2.0中不可以，只需直接把标识符写成驼峰的即可</p>
<p>商家实景：</p>
<p>一开始能滚动，但当切换选项卡的时候，又不能滚动了</p>
<p>自己的解决办法是：通过在mounted里面再加上<code>this._initPics();</code>解决，发现无论是加不加 <code>this.$nextTick</code>都没有妨碍…</p>
<h3 id="收藏"><a href="#收藏" class="headerlink" title="收藏"></a>收藏</h3><p>要实现点击的时候图标不能动，设置固定宽度的时候就不会动了</p>
<p>设置<code>width: 50px</code>，<code>icon为24px</code>，<code>26/2= 13px</code>，然后就只需要设置<code>right</code>为5px即可，实现原来的<code>right: 18px</code>的效果，但是当文字变成3个字的时候，注意设计稿是相对文字的<code>right: 18px</code>，所以还是要改一下，三个字的时候<code>width:36px</code>，<code>(50-36)/2=7</code>，则right应该为<code>11px</code></p>
<p>点击了收藏，之后刷新页面，又变成了未收藏，怎么解决？ 把收藏的状态缓存到localstorage</p>
<p>考虑一下真实的开发流程，我们的url肯定会是有一个seller的id的(类似于<code>http://localhost:8090/？id=123#/seller</code>)，收藏也应该是相对于id来进行的，这样的话，就需要从一开始的app.vue的seller对象里面取出url里面的id选项</p>
<h3 id="util-js来从url中获取id"><a href="#util-js来从url中获取id" class="headerlink" title="util.js来从url中获取id"></a>util.js来从url中获取id</h3><p>编写一个util.js来从url中获取id的值</p>
<p>但是能获取到url之中id值的时候，在组件刚创建的时候的<code>this.seller = response.data;</code>直接复制<code>seller</code>，会把在data里面定义的<code>id</code>属性丢弃掉，因为<code>response.data</code>里面是不包含id的，我们可以用<code>Object.assign</code>去给seller做一个赋值，<code>Object.assign</code>接受三个数据，一个是最终要接受的数据(要返回的结果)，相当于用<code>extends</code>的方式去扩展了seller，也就是在data里seller的id的基础上，给seller添加了其他的属性</p>
<p>获得了id之后，回到seller组件，那么在点选收藏的时候，我们可不可以直接<code>localStorage.favorite = this.favorite;</code>，肯定不可以的，因为当不同id的时候，都存的是favorite</p>
<h3 id="通用的存储的localStorage库"><a href="#通用的存储的localStorage库" class="headerlink" title="通用的存储的localStorage库"></a>通用的存储的localStorage库</h3><p>设计一个通用的存储的localStorage库</p>
<p>注意，要在localstorage前，加上window.storage，指明命名空间，不然webpack会报错，node中是没有叫storage的</p>
<p>小bug: 与视频不同的是，在<code>localstorage</code>中，总会多出一个undefined的属性…</p>
<pre><code>Storage {__seller__: &quot;{&quot;1235&quot;:{&quot;favorite&quot;:true},&quot;undefined&quot;:{&quot;favorite&quot;:true}}&quot;, length: 1}
</code></pre><p>发现当没有定义读(<code>loadFromLoacl</code>)的时候，也即没有在组件中导入，同时data中还是直接<code>return { favorite: false };</code>的时候，就是会出现上述情况，而且当点击收藏的时候，变动的只有<code>&quot;undefined&quot;:{&quot;favorite&quot;:true}</code>这里面的true或false</p>
<p>get: 在saveToLocal中对<code>id，key，value</code>进行一下log会输出<code>undefined &quot;favorite&quot; true</code>，也就是在<code>toggleFavorite</code>的时候传入的<code>this.seller.id</code>没有值，</p>
<p>再次记录当一打开时是<code>http://localhost:8090/#/seller</code>，给其加上<code>?id=123</code>后按enter进入，此时如果是未引入loadFromLocal和修改data里面的return，localStorage为<code>{&quot;123&quot;:{&quot;favorite&quot;:true},&quot;undefined&quot;:{&quot;favorite&quot;:true}}</code>，但是引入后，重新npm run dev发现</p>
<p>bingo!(简直心路历程): 初步判定两种情况：</p>
<ol>
<li>第一种是因为一开始启动url是没有id值的，直接按了收藏此时<code>undefined</code></li>
<li>第二种情况，但后来加上url，但是没有在地址栏里跳转就以为可以了</li>
</ol>
<p>性能优化：每次从三个选项卡中切换的时候，都会’跳’一下，这是因为我们的dom被重新渲染了，vue的生命周期被重新执行了一遍，还有一个很严重的问题，我们在商品选项卡下将很多商品添加都购物车里面，但是呢，切换其他选项卡后，再跳回，会发现购物车里的东西全部没有了，我们希望这些状态能被保留</p>
<p>很简单：使用<code>keep-alive</code>，它的原理就是把组件的一些状态缓存到内存里，当我们切换router的时候，如果组件已经加载过并被保存在内存里面，它就从内存里将它恢复</p>
<h2 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h2><p><code>npm run build</code>，<code>webpack</code>配置有关，生成一个node的<code>pro-server.js</code>用来验证生成的dist目录是否可行</p>
<h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><p>用小技巧：</p>
<ol>
<li><p>判断组件是否被引用成功，在新建的vue组件中<code>export default {};</code>，然后其他组件引用后，使用<code>&lt;shopcart&gt;&lt;/shopcart&gt;</code>，此时打开浏览器，查看是否变成<code>&lt;div class=&quot;shopcart&quot;&gt;&lt;/div&gt;</code>即可</p>
</li>
<li><p>可以通过ES6的反斜杠字符串来避免写很多的+号连接字符串，如<code>￥${this.minPrice}元起送</code></p>
</li>
<li><p>字体图标例如减号加号是很小，用户希望点击减和加尽量的区域大点，此时可以通过设置padding</p>
</li>
<li><p>可以被外部调用的方法正常写，下划线开头的方法只能被内部调用，也就是下划线的方法都是组件的私有的方法</p>
</li>
</ol>
<h2 id="eslint配置"><a href="#eslint配置" class="headerlink" title="eslint配置"></a>eslint配置</h2><pre><code>data() {  //注意括号后面要接上一个空格，这是es6的规范

},
</code></pre><p>可以在rules通过在相应的规则后面加0，设置不对其进行检查</p>
<p><code>&#39;space-before-function-paren&#39;: 0</code></p>
<pre><code>&lt;script&gt;
  .../*在这里写es6语法的，ws会不认识，除非对script标签设置了type=&quot;text/ecmascript-6&quot;*/ 
&lt;/script&gt; 
</code></pre><p>箭头函数前后需要有空格</p>
<pre><code>/* eslint-disable: no-unused-vars */不检查没有使用的值
</code></pre>
  </article>
</div>

<script type="text/javascript" src="../../../../js/post.js"></script>
</body>
</html>